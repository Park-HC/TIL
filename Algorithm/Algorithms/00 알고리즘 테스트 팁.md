# 알고리즘 테스트

## 알고리즘 테스트의 목표

- 입력 test case를 처리하여 정확한 출력을 내보내는 것



## 문제 풀이 단계

1. 문제 읽기
2. 접근방법 구상
3. 핵심코드 손코딩
4. 코드 구현
5. 디버깅 및 개선



## 접근방법 구상

### 유형

- 이전 풀었던 문제와 유사한지, 특정 자료 구조 적용 가능한지, 전형적인 알고리즘 적용 가능한지 체크

### 규칙성

- 제한 시간 내 문제 설명의 예시르 처리하는 것이 가능한지
- 여러 입력에 대한 출력을 계산하며(규칙성, 조건, 수식) 적용 가능한지 체크

### 일반 처리

- 가능한 모든 경우를 처리하면서 풀이 가능한지 체크
- divide & conquer
- 반대로 접근하는 경우 체크

### 시각적(손 그림) 접근



## 문제풀이 연습

### 기본기

- 기본기가 탄탄해야 구상한 아이디어를 실수 없이 구현 가능
  - 정확한 입출력
  - 실수 없는 2차원 배열
  - 다중 루프 제어
- 효율적인/짧은/멋진 코드보다 기본적인 반복, 조건을 빈틈없이 구현
- 손코딩: 주요 array, 범위, 핵심코드를 실명/시각적으로 설계하고 접근
- 디버거 사용법 숙지



### 환경

- 폰트, 폰트 크기, 창 배치, 입력 파일, A4 용지, 풀이 순서 등 환경 조정
- 입력 받는 변수, 선언 변수, 특정 용도 사용 변수 등에 익순한 이름 사용
- 함수 호출, 조건, 반복, break, continue 등 익숙한 방법으로 구현



## 알고리즘 요구사항 분석

### 시간 복잡도(수행 시간)

- python은 초당 2000만번, 5초에 1억번 연산한다고 가정
- 연산 획수 5억일 때 C언어는 1~3초, python은 5~15초

| N의 max  | 빅O              |
| -------- | ---------------- |
| 500      | O(N<sup>3</sup>) |
| 2000     | O(N<sup>2</sup>) |
| 100000   | O(N logN)        |
| 10000000 | O(N)             |

- 일반적으로 시간복잡도와 공간복잡도는 반비례하는 경향



### 데이터 구조 별 메소드 수행 시간

#### 배열

- Lookup(position), Assign: O(1)
- Insert, Remove, Find(value): O(n)



#### 연결리스트(Linked List)

- Lookup(position), Assign, Find(value): O(n)
- Insert: O(1) (끝단에 추가 시)
- Remove
  - 단일 연결리스트 : O(n)
  - 이중 연결리스트: O(1)



#### 트리(Trees)

- Find
  - 일반 트리: O(n)
  - 이진 검색 트리: O(log n)
    - 단, 정렬을 위해 추가시마다 밸런스 조정되야 함



### 시간 측정 코드

```python
import time
start_time = time.time()

# 프로그램 소스 코드
end_time = time.time()
print('time:', end_time - start_time)
```



## Python 함수

### sys.setrecursionlimit(num)

- 재귀함수에서 다시 재귀함수를 부를 수 있는 횟루를 num까지 늘림
- 설정이 안 되어 있을 경우 1000번이 한계







참조:

https://velog.io/@jehjong/Python-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EB%B6%84%EC%84%9D-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84

https://velog.io/@leobit/%EB%B3%B5%EC%9E%A1%EB%8F%84Complexity

