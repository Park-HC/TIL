# 큐(Queue)

## 개요

- 삽입과 삭제의 위치가 제한적인 자료구조
- 선입선출구조(FIFO)
  - 삽입된 원소는 큐 맨 뒤에 놓이고 삭제는 맨 앞에서 진행됨
  - 가장 먼저 삽입된 원소가 가장 먼저 삭제됨



## 연산

| 연산          | 기능                                                |
| ------------- | --------------------------------------------------- |
| enQueue(item) | 큐의 뒤쪽(rear 다음)에 원소를 삽입하는 연산         |
| deQueue()     | 큐의 앞쪽(front)에 원소를 삭제하고 반환하는 연산    |
| createQueue() | 공백 상태의 큐를 생성하는 연산                      |
| isEmpty       | 큐가 공백상태인지를 확인하는 연산                   |
| isFull()      | 큐가 포화상태인지를 확인하는 연산                   |
| Qpeek()       | 큐의 앞쪽(front)에서 원소를 삭제 없이 반환하는 연산 |



## 선형큐

### 개요

- 1차원 배열 큐

- 큐의 크기 = 배열의 크기
- `front`: 저장된 첫 번째 원소의 인덱스
- `rear`: 저장된 마지막 원소의 인덱스



### 상태표현

- 초기 상태: front = rear = -1
- 공백 상태: front == rear
- 포화 상태: rear == n-1 (n: 배열의 크기, n-1: 배열의 마지막 인덱스)



### 구현

#### createQueue()

- 크기가 n인 1차원 리스틔 생성
- front, rear = -1



#### enQueue()

- rear 값 하나 증가시켜 새로운 원소를 삽입할 자리 마련
- 그 인덱스에 해당하는 리스트 원소 Q[rear]에 item 저장



#### deQueue()

- front 값 하나 증가시켜 큐에 남아 있는 첫 번째째 원소로 이동함
- 새로운 첫 번째 원소를 리턴하면서 `pop()`와 동일한 기능을 함



#### isEmpty(), isFull()

- 공백상태: front = rear
- 포화상태: rear = n - 1



#### Qpeek()

- 가장 앞에 있는 원소를 반환
- 비어 있으면 -1 반환



### 장점

- 삽입, 삭제의 처리 속도 빠름



### 단점: 잘못된 포화 상태 인식 문제

- 선형 큐를 이용하여 원소의 삽입과 삭제를 반복하면 rear가 n-1까지 밀려 앞에 공간이 있음에도 삽입을 수행하지 않게 됨

#### 해결방법

1. 매 연산마다 저장된 원소들을 배열의 앞부분으로 이동시키는 해결 방법
   - 이동에 시간이 많이 소요되어 큐의 효율성이 급격히 떨어짐
2. n을 충분히 크게 지정함
   - 메모리 낭비가 심함

3. 큐가 원형이라 가정, 구현
   - 원형 큐
4. 단순 연결 리스트로 구현한 큐를 사용
   - 메모리를 동적 확보함
5. 큐 라이브러리



## 원형 큐

### 개요

- 초기 공백 상태: front = rear = 0
- front와 rear가 마지막 인덱스인 n-1를 가리킨 후 그 다음에는 논리적 순환을 통해 배열 처음 인덱스인 0으로 이동
- 공백과 포화 상태 구분을 위해 front가 있는 자리는 사용하지 않고 빈자리로 둠

| 테이블 인덱스 | 삽입 위치             | 삭제 위치               |
| ------------- | --------------------- | ----------------------- |
| 선형 큐       | rear = rear + 1       | front = front + 1       |
| 원형 큐       | rear = (rear + 1) % n | front = (front + 1) % n |



### 구현

#### createQueue()

- 크기가 n인 1차원 리스트 생성
- front, rear = 0으로 초기화



#### isEmpty(), isFull()

- 공백상태: front = rear
- 포화상태: 삽입할 rear의 다음 위치 = 현재 front
  - `(rear + 1) % n =front`



#### enQueue(item)

- rear 값을 조정하여 새로운 원소를 삽입할 자리를 마련
  - `rear = (rear + 1) % n`
- 인덱스에 해당하는 마지막 원소 C[rear]에 item 삽입



#### deQueue(), delete()

- front 값을 조정하여 삭제할 자리를 준비
- 새로운 front 원소를 리텀함으로써 삭제와 동일한 기능



## 리스트 큐

### 개요

- Python의 리스트 특성을 사용한 큐
- 리스트 크기를 동적으로 변경할 수 있음
- 메모리 절약
- 삽입, 삭제 시 복사, 데이터 이동에 많은 연산 필요
- front = -1
- rear = len(queue) - 1
- front와 rear를 직접 변경할 필요 없음



### 구현

#### append(item)

- 마지막 위치에 원소 추가

#### pop(index)

- index 위치에 원소 삭제





## 연결 큐

### 개요

- 연결 리스트 형식을 이용해 구현
- 원소: 단순 연결 리스트의 노드
- 원소 순서: 노드의 연결 순서, 링크로 연결되어 있음
- front, rear: 각각 첫 번째, 마지막 노드를 가리킴



### 상태 표현

#### 초기, 공백 상태

- front, rear = None



## 우선순위 큐

### 개요

- 우선 순위를 가진 항목들을 저장하는 큐
- FIFO 순서가 아니라 우선 순위가 높은 대로 먼저 나감

- 배열이나 리스트를 사용해 구현 가능



### 적용 분야

- 시뮬레이션 시스템
- 네트워크 트래픽 제어
- 운영체제의 테스크 스케줄링



### 배열을 이용한 우선순위 큐

#### 개요

- 배열을 이용하여 자료 저장
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
- 가장 앞에 최고 우선순위의 원소가 위치하게 됨



#### 문제점

- 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생
- 이에 소요되는 시간이나 낭비가 큼



## 버퍼

### 개요

- 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
- 버퍼링은 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미



### 자료 구조

- 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용
- 순서대로 입력, 출력, 전달되어야 하므로 FIFO 방식의 큐 자료구조가 활용됨