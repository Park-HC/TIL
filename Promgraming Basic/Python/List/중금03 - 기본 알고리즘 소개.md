# 기본 알고리즘 소개

## 완전탐색

> Brute-force 혹은 Generate-and-Test 기법

### 정의

문제의 해법으로 생각할 수 있는 모든 경우를 나열해 보고 확인하는 기법

### 특성

1. 경우의 수가 작을 때 유용
2. 수행 속도는 느리지만 해답을 찾을 가능성이 높음
3. 주어진 문제 풀이시, 완전탐색으로 먼저 해결하는 방법이 있음

## 탐욕 알고리즘(Greedy Algorithm)

### 정의

> 근시안적 방법

* 여러 경우 중 하나를 결정할 때, 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
* 국지적으로는 최적이지만, 최종적으로도 최적해가 되리란 보장은 없음
* 혹은, 탐욕 알고리즘으로 해를 못 찾았어도 실제로 해가 존재할 수 있음

### 탐색 과정

1. 해 선택

   현상태에서 최적해를 구한 후, 이를 부분 해 집합에 추가

2. 실행 가능성 검사

   새로운 부분해 집합이 실행가능하며, 제약 조건 위배하지 않는지 판단

3. 해 검사

   새로운 부분 해 집합이 문제의 해가 되는지 확인

   아니라면 해 선택으로 되돌아감

## 정렬(Sort)

### 정의

2개 이상의 자료를 특정 기준에 의해 오름자춘/내림차순으로 재정렬하는 것

### 정렬 방식

#### 버블 정렬

> 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식

##### 슈도코드

```python
def BubbleSort(a):
    for i in range(len(a)-1, 0, -1):
        for j in range(i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1],a[j]
```



##### 시간 복잡도

```python
O(n^2)
```



#### 카운팅 정렬

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여
>
> 선형 시간에 정렬하는 효율적인 알고리즘

*정수형 자료구조에서만 사용가능*

##### 슈도 코드

```python
def CountingSort(A, B, k):
# A[]: 입력 리스트에 사용된 숫자
# B[]: 정렬된 리스트
# C[]: 카운트 리스트
    C = [0] * k
    
    for i in range(0, len(B)):
        C[A[i]] += 1
    for i in range(1, len(C)):
        C[i] += C[i-1]
    
    for i in range(len(B)-1, -1, -1):
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1
```



##### 시간 복잡도

```python
O(n+k): n은 리스트의 개수, k는 정수의 최대값
```



#### 선택 정렬

#### 퀵 정렬

#### 삽입 정렬

#### 병합 정렬