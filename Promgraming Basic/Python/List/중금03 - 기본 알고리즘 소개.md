# 기본 알고리즘 소개

## 완전탐색

> Brute-force 혹은 Generate-and-Test 기법

### 정의

문제의 해법으로 생각할 수 있는 모든 경우를 나열해 보고 확인하는 기법

### 특성

1. 경우의 수가 작을 때 유용
2. 수행 속도는 느리지만 해답을 찾을 가능성이 높음
3. 주어진 문제 풀이시, 완전탐색으로 먼저 해결하는 방법이 있음

## 탐욕 알고리즘(Greedy Algorithm)

### 정의

> 근시안적 방법

* 여러 경우 중 하나를 결정할 때, 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
* 국지적으로는 최적이지만, 최종적으로도 최적해가 되리란 보장은 없음
* 혹은, 탐욕 알고리즘으로 해를 못 찾았어도 실제로 해가 존재할 수 있음

### 탐색 과정

1. 해 선택

   현상태에서 최적해를 구한 후, 이를 부분 해 집합에 추가

2. 실행 가능성 검사

   새로운 부분해 집합이 실행가능하며, 제약 조건 위배하지 않는지 판단

3. 해 검사

   새로운 부분 해 집합이 문제의 해가 되는지 확인

   아니라면 해 선택으로 되돌아감
   
   

## 정렬(Sort)

### 정의

2개 이상의 자료를 특정 기준에 의해 오름자춘/내림차순으로 재정렬하는 것

### 정렬 방식

#### 버블 정렬

> 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식

##### 슈도코드

```python
def BubbleSort(a):
    for i in range(len(a)-1, 0, -1):
        for j in range(i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1],a[j]
```



##### 시간 복잡도

```python
O(n^2)
```



#### 카운팅 정렬

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여
>
> 선형 시간에 정렬하는 효율적인 알고리즘

*정수형 자료구조에서만 사용가능*

##### 슈도 코드

```python
def CountingSort(A, B, k):
# A[]: 입력 리스트에 사용된 숫자
# B[]: 정렬된 리스트
# C[]: 카운트 리스트
    C = [0] * k
    
    for i in range(0, len(B)):
        C[A[i]] += 1
    for i in range(1, len(C)):
        C[i] += C[i-1]
    
    for i in range(len(B)-1, -1, -1):
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1
```



##### 시간 복잡도

```python
O(n+k): n은 리스트의 개수, k는 정수의 최대값
```



#### 선택 정렬

##### 셀렉션 알고리즘

- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
- 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 함
- 정렬 알고리즘을 이용해 자료를 정렬
- 원하는 순서에 있는 원소를 찾아 옴



##### 선택정렬의 정의

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택해 위치를 교환하는 방식
- 셀렉션 알고리즘을 전체 자료에 적용한 것
- O(n^2)



#### 퀵 정렬

#### 삽입 정렬

#### 병합 정렬



## 검색

> 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
>
> 목적하는 탐색키를 가진 항목을 찾는 작업

### 순차 검색

- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
- list나 연결 list 등 순차구조로 구현된 자료구조에서 유용함
- 구현이 쉽지만, 검색 대상이 많은 경우 수행시간이 크게 증가함



#### 정렬되지 않는 자료의 검색

- 첫번째 원소부터 순서대로 검색대상과 키 값이 같은 원소가 있는지를 비교하여 찾음
- 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환
- 자료구조 마지막까지 대상이 없으면 검색 실패
- O(n)



#### 정렬된 자료의 검색

- 순차적으로 키 값 비교
- 검색하려는 값보다 큰 키 값이 나오면 검색 실패
- O(n)



### 이진 검색

- 효율적임
- 자료 가운데 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속함
- 검색 범위를 반으로 줄여가며 빠르게 검색
- 자료가 정렬된 상태여야 함
- 재귀함수로 구현 가능
- O(logN)



### 인덱싱

- 데이터베이스에서 유래
- 테이블에 대한 동작 속도를 높임
- 룩 업 테이블 등의 용어로 사용함
- 인덱스 저장에 필요한 디스크 공간은 보통 테이블 저장에 필요한 공간보다 작음
  - 키-필드만 가지고 있기 때문
- List를 사용해 인덱스를 만들 수 있음
  - 대량의 데이터를 일일히 정려하는 것보다, 데이터를 참조하는 List의 인덱스를 사용하는 게 더 효율적임

