# 상속

```java
public class Person { }
public class Student extends Person { }
```

- 클래스 선언시 `extends` 키워드로 명시
- 어떤 클래스를 부모로 삼으면 자식 클래스에서는 부모 클래스의 변수와 함수들도 함께 정의됨
  - 부모의 생성자와 초기화 블록은 상속되지 않음
  - 접근 제한자에 따라 접근 불가능한 것이 있을 수 있음
  - 확장성, 재사용성 높음
- Object는 사실 모든 클래스의 조상
  - 별도의 extends 선언이 없는 클래스는 extends Object가 생략됨

## 생성자

```java
// 생성자
public class Person { }
public class Student extends Person { 
	Student() {
        super(); // 부모 클래스 생성자의 호출, 상속을 받으면 생성자의 (암묵적으로) 첫 줄에서 이 문장을 수행
        // 부모클래스에 기본 생성자가 없는 경우 자식 클래스 생성자의 첫 줄에서 명시적으로 부모 클래스의 생성자를 호출해야 함
    }
}
```



## 오버라이딩

```java
// 오버라이딩
public class Person { 
	public void eat() {
        System.out.println("음식을 먹는다.");
    }
}
public class Student extends Person { 
	public void eat() {
        System.out.println("급식을 먹는다.");
    }
} // 자식 함수에 부모가 정의한 함수와 동일한 이름에 동일한 포맷의 메서드가 있다면
  // 자식 영역에서 이름으로 함수를 부르면 자식 클래스의 메소드만이 응한다
public class HungryStudent extends Person {
    @Override // 애노테이션
    		  // 컴파일러가 참조하는 주석으로 그 자체로 기능은 없지만 컴파일 시 컴파일러가 애노테이션을 따라 검증을 해봄
	public void eat() {
        super.eat();
        System.out.println("급식을 먹는다.");
    } // 이 경우 부모 클래스의 eat 함수를 같이 실행
}
```

- 상위 클래스에 선언된 메소드를 자식 클래스에서 재정의
- 메서드의 이름, 반환형, 매개변수 (타입, 개수, 순서) 모두 동일해야 함
- 하위 클래스의 접근제어자 범위가 상위 클래스보다 크거나 같아야 함
- 메서드 오버로딩과 다른 것!!



### Object 클래스

- 최상위 클래스
- 모든 클래스의 조상
- Object의 멤버는 모든 클래스의 멤버
- `toString(), equals(), hashCode(), getClass()`등을 Object에 포함된 메소드는 자식 클래스에서도 사용 가능함



### final

- 접근 제한자

기능 1. 변수를 상수화 시킴(한 번 선언된 변수를 다시 수정할 수 없게 보증함)

기능 2. 메소드는 자식 클래스에서 오버라이딩을 금지시킴

기능 3. 클래스는 상속 되지 않게 함



# 다형성

## 개요

- 상속관계에 있을 때 조상 클래스의 타입으로 자식 클래스 객체를 참조 가능

## 기능

### 1. 다른 타입의 객체를 다루는 배열

- Student가 Person의 자식 클래스일 경우, Person array에 Student 클래스 데이터도 넣을 수 있다

### 2. 매개변수의 다형성

- 조상을 파라미터로 처리한다면 (자식 클래스들에 한해) 객체의 타입에 따라서 메서드를 만들 필요가 없음

